# Pre-computed look-up table of total_after from 1 to 64
# Generated by '[total_after2(x) for x in range(1,65,1)]' and
# copied directly. Instead, could have generated it from on_square, but
# since total_after(64) is an extra power of 2 above on_square(64),
# decided to go with total_after as the generator, and then treat
# on_square3(1) as a special case.
# Have to be careful in the calling functions, because the list index range
# is from 0 to 63, but the code inputs are from 1 to 64
TOTAL_LOOKUP = [1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191,
                16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151,
                4194303, 8388607, 16777215, 33554431, 67108863, 134217727,
                268435455, 536870911, 1073741823, 2147483647, 4294967295,
                8589934591, 17179869183, 34359738367, 68719476735,
                137438953471, 274877906943, 549755813887, 1099511627775,
                2199023255551, 4398046511103, 8796093022207, 17592186044415,
                35184372088831, 70368744177663, 140737488355327,
                281474976710655, 562949953421311, 1125899906842623,
                2251799813685247, 4503599627370495, 9007199254740991,
                18014398509481983, 36028797018963967, 72057594037927935,
                144115188075855871, 288230376151711743, 576460752303423487,
                1152921504606846975, 2305843009213693951, 4611686018427387903,
                9223372036854775807, 18446744073709551615]

# Pre-computed look-up table of on_square from 1 to 64
# Generated by '[on_square2(x) for x in range(1,65,1)]' and
# copied directly.
ONSQUARE_LOOKUP = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096,
                   8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576,
                   2097152, 4194304, 8388608, 16777216, 33554432, 67108864,
                   134217728, 268435456, 536870912, 1073741824, 2147483648,
                   4294967296, 8589934592, 17179869184, 34359738368,
                   68719476736, 137438953472, 274877906944, 549755813888,
                   1099511627776, 2199023255552, 4398046511104, 8796093022208,
                   17592186044416, 35184372088832, 70368744177664,
                   140737488355328, 281474976710656, 562949953421312,
                   1125899906842624, 2251799813685248, 4503599627370496,
                   9007199254740992, 18014398509481984, 36028797018963968,
                   72057594037927936, 144115188075855872, 288230376151711744,
                   576460752303423488, 1152921504606846976,
                   2305843009213693952, 4611686018427387904,
                   9223372036854775808]


def on_square(i):
    """
    The value of on_square at square i is just 2^(i-1), since we are doubling
    always, and start with 1 grain on square 1.
    """
    if i < 1 or i > 64:
        raise ValueError('Invalid index %d: should be between 1 and 64' % i)

    # Careful of the exponent; the range is 1-64, but the
    # exponent is one less than that. Why? On square 1, we
    # have not doubled yet, so it's 2^0=1; on square 2, we
    # have doubled once, so it's 2^1=2 and so on.

    return 2 ** (i-1)


def on_square2(i):
    if i < 1 or i > 64:
        raise ValueError('Invalid index %d: should be between 1 and 64' % i)

    # Careful of the exponent; the range is 1-64, but the
    # exponent is one less than that. Why? On square 1, we
    # have not doubled yet, so it's 2^0=1; on square 2, we
    # have doubled once, so it's 2^1=2 and so on.

    # Use bit-shifts instead of exponential
    return 1 << (i-1)


def on_square3(i):
    if i < 1 or i > 64:
        raise ValueError('Invalid index %d: should be between 1 and 64' % i)

    # Special case: if the input is '1' then the table lookup below
    # will fail with index out of bounds.
    if i == 1:
        return 1

    # Use the lookup table (indexed from 0 to 63)
    return TOTAL_LOOKUP[i-2] + 1


def on_square4(i):
    if i < 1 or i > 64:
        raise ValueError('Invalid index %d: should be between 1 and 64' % i)

    # Use the lookup table (indexed from 0 to 63)
    return ONSQUARE_LOOKUP[i-1]


def total_after(i):
    """
    The value of total_after at square i is 2^0 + 2^1 + .. + 2^i, since
    we are summing up all of the on_square values and start with 1 grain
    on square 1.
    """
    if i < 1 or i > 64:
        raise ValueError('Invalid index %d: should be between 1 and 64' % i)

    # sum = 0
    # # The range() function goes from 0 to i, which is exactly what we
    # # want here. The sum of 3 chess squares would be 2^0 + 2^1 + 2^2.
    # for i in range(i):
    #     sum += (2 ** i)
    # return sum

    # Agh, forgot the formula that sum of the geometric series 2^k, where
    # k=0,1,2.. is 2^(k+1) - 1.
    return (2 ** i) - 1


def total_after2(i):
    if i < 1 or i > 64:
        raise ValueError('Invalid index %d: should be between 1 and 64' % i)

    # Agh, forgot the formula that sum of the geometric series 2^k, where
    # k=0,1,2.. is 2^(k+1) - 1.

    # Use bit-shifts instead of exponential
    return (1 << i) - 1


def total_after3(i):
    if i < 1 or i > 64:
        raise ValueError('Invalid index %d: should be between 1 and 64' % i)

    # Use the lookup table (indexed from 0 to 63)
    return TOTAL_LOOKUP[i-1]


# Discussion:
#
#
# on_square:
#
# For on_square(), I went straight to the exponent; I guess you could
# write a loop to do the exponentiation via multiplication if you wanted
# a more naive approach?
#
# To optimise on_square2(), I used a bit-shift instead. If you haven't seen
# it before, then it's less obvious/readable than the exponentiation.
#
# To optimise further on_square3(), I thought about a pre-computed
# lookup-table, since 1-64 is not a huge range of numbers. To reduce code,
# I wanted to use the same lookup-table for both on_square3() and
# total_after3(). Looking at the performance figures below, it actuall
# gets slower! That is likely a combination of the 'if i==1' special case
# (conditionals slow things down), and the extra sum '+ 1'.
#
# Just to finish it off then with on_square4() with its own lookup table
# and remove those additional bits of code (compared to on_square3()). The
# performance is a slight improvement over on_square2().
#
#
# total_after:
#
# For total_after(), I did start with the naive loop/sum approach. I wasn't
# thinking that of course there's a nice formula, but had a sneaking
# suspicion that I was missing something obvious. Doh, once I found it after
# a quick search online!
#
# Again, to optimise a bit more, use bit-shift in total_after2().
#
# To optimise further total_after3(), I thought about a pre-computed
# lookup-table, since 1-64 is not a huge range of numbers.
#
# In terms of performance checking, I didn't know how best to benchmark
# Python code. I found out about timeit, so used the following to see
# the performance.
#
#
# Benchmarks of the different on_square versions:
# >>> timeit.timeit("from grains import on_square; " +
# "[on_square(x) for x in range(1,65,1)]", number=100000)
# 2.728085715090856
# >>> timeit.timeit("from grains import on_square2; " +
# "[on_square2(x) for x in range(1,65,1)]", number=100000)
# 1.2246633521281183
# >>> timeit.timeit("from grains import on_square3; " +
# "[on_square3(x) for x in range(1,65,1)]", number=100000)
# 1.5584465300198644
# >>> timeit.timeit("from grains import on_square4; " +
# "[on_square4(x) for x in range(1,65,1)]", number=100000)
# 1.1705864588730037
#
#
# Benchmarks of the different total_after versions:
# >>> timeit.timeit("from grains import total_after; " +
# "[total_after(x) for x in range(1,65,1)]", number=100000)
# 2.867814442142844
# >>> timeit.timeit("from grains import total_after2; " +
# "[total_after2(x) for x in range(1,65,1)]", number=100000)
# 1.2931673359125853
# >>> timeit.timeit("from grains import total_after3; " +
# "[total_after3(x) for x in range(1,65,1)]", number=100000)
# 1.1668689781799912
